{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "openai": {
      "models": {
        "gpt-5-codex": {
          "options": {
            "reasoningEffort": "high",
            "reasoningSummary": "auto"
          }
        }
      }
    }
  },
  "agent": {
    "build": {
      "model": "opencode/gpt-5.1-codex"
    },
    "plan": {
      "model": "opencode/gemini-3-pro"
    },
    "fast-build": {
      "model": "anthropic/claude-haiku-4-5-20251001"
    },
    "grok-free-build": {
      "model": "opencode/grok-code"
    }
  },
  "command": {
    "commit_push": {
      "template": "commit and push (1 or more logical commits)\n\nAnalyze the current changes and create logical, well-structured commits with descriptive messages. Group related changes together and push all commits to the remote repository.",
      "description": "Create logical commits and push to remote",
      "agent": "build"
    },
    "jj_pr": {
      "template": "Create a jj bookmark and GitHub PR for current working copy\n\nFollow these steps:\n1. Run `jj status` to check current state\n2. Handle bookmarks:\n   - Run `jj bookmark list` to see existing bookmarks\n   - If a bookmark already exists for this work, use `jj bookmark set existing-bookmark-name` to set it to current commit\n   - If no appropriate bookmark exists, create new one with `jj bookmark create feature/descriptive-name`\n3. Push to GitHub with `jj git push --bookmark your-bookmark-name --allow-new`\n4. Create PR with `gh pr create --head your-bookmark-name --base master --title \"Your descriptive title\" --body \"Detailed description\"`\n\nUse descriptive bookmark names like feature/add-user-auth, fix/memory-leak, docs/api-guide. The working copy changes are automatically included when you create or set a bookmark. Always specify --head and --base explicitly when using gh pr create.",
      "description": "Push jj working copy to branch and create GitHub PR",
      "agent": "build"
    },
    "prepare_pr": {
      "template": "Prepare current branch for PR with comprehensive review and fixes\n\nFollow these steps:\n1. Commit any uncommitted changes:\n   - Check git status to see uncommitted changes\n   - Create a logical commit with a descriptive message for any uncommitted work\n\n2. Review ALL changes on the branch since it diverged from main/master:\n   - Run `git diff main...HEAD` (or `git diff master...HEAD`) to see all changes\n   - Run `git log main..HEAD` (or `git log master..HEAD`) to see all commits\n   - Review the code thoroughly for:\n     a) Leftover or redundant code (commented-out code, unused variables, dead code paths)\n     b) Logic clarity - ensure code is explicit, simple, and modular\n     c) Fail-fast patterns - check errors are caught early and handled properly\n     d) Code smells (long functions, duplicated code, unclear naming, tight coupling)\n     e) Comments - go over all added comments and for each:\n        - Remove it if the code is self-explanatory\n        - Remove it but extract non-self-explanatory code into a function with descriptive name\n        - Keep it only if it explains the WHY (not the HOW)\n\n3. Fix any issues found:\n   - Remove redundant code\n   - Simplify complex logic\n   - Extract functions to improve modularity\n   - Add early returns and proper error handling\n   - Improve naming and structure\n   - Apply comment review decisions\n\n4. Run relevant tests:\n   - Identify which tests are relevant based on the changes\n   - Run those tests and ensure they pass\n   - Fix any test failures\n\nIMPORTANT: If you encounter any dilemma or ambiguity during the review (e.g., uncertain if code is redundant, unclear if a refactoring would break something, unsure about business logic), PAUSE and ask the user for guidance before proceeding.",
      "description": "Commit changes, review branch code, fix issues, run tests",
      "agent": "build"
    }
  }
}
