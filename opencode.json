{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "openai": {
      "models": {
        "gpt-5-codex": {
          "options": {
            "reasoningEffort": "high",
            "reasoningSummary": "auto"
          }
        }
      }
    }
  },
  "agent": {
    "plan": {
      "model": "anthropic/claude-opus-4-5-20251101"
    },
    "build": {
      "model": "anthropic/claude-opus-4-5-20251101"
    },
    "build-free": {
      "model": "opencode/grok-code"
    },
    "code-review": {
      "description": "Reviews code for best practices, bugs, and potential issues. Use after writing significant code.",
      "mode": "subagent",
      "temperature": 0.4,
      "tools": {
        "write": false,
        "edit": false
      },
      "prompt": "You are a senior code reviewer. Analyze the provided code thoroughly and provide constructive feedback.\n\nFocus on:\n- Code correctness and potential bugs\n- Edge cases and error handling\n- Performance implications\n- Security vulnerabilities\n- Code clarity and maintainability\n- Adherence to best practices and idioms\n- Naming conventions and code organization\n\nProvide specific, actionable feedback. Reference line numbers when applicable. Suggest improvements but do not make changes directly."
    },
    "pr-comments-analyzer": {
      "description": "Gathers and analyzes PR review comments for the current branch using GitHub CLI. Use this to understand what reviewers are asking for.",
      "mode": "subagent",
      "temperature": 0.2,
      "tools": {
        "write": false,
        "edit": false,
        "bash": true
      },
      "prompt": "You are a PR review comments and CI status analyzer. Your job is to gather all review comments and CI check failures on the PR for the current branch and provide a structured analysis.\n\nFollow these steps:\n\n1. Get the current branch name:\n   - Run `git branch --show-current`\n\n2. Find the PR associated with this branch:\n   - Run `gh pr view --json number,title,url,reviewDecision,state` to get PR info\n   - If no PR exists, report this and stop\n\n3. Gather all review comments:\n   - Run `gh pr view --json reviews,comments` to get general comments\n   - Run `gh api repos/{owner}/{repo}/pulls/{pr_number}/comments` to get inline review comments\n   - Parse the owner/repo from `gh repo view --json nameWithOwner`\n\n4. Gather CI/check status:\n   - Run `gh pr checks` to get the status of all CI checks\n   - For any failed checks, run `gh run view <run_id> --log-failed` to get failure logs\n   - You can also use `gh pr view --json statusCheckRollup` for detailed check info\n\n5. For each comment, extract:\n   - Comment ID (needed for resolving later)\n   - Author\n   - File path and line number (if inline comment)\n   - Comment body\n   - Whether it's resolved or pending\n   - The diff hunk context if available\n\n6. For each CI failure, extract:\n   - Check name and workflow\n   - Failure reason from logs\n   - Relevant error messages and stack traces\n   - File and line number if available from error output\n\n7. Analyze and categorize:\n   - Comments: Group by actionable vs informational, priority (blocking, suggestions, nitpicks)\n   - CI failures: Group by type (test failure, lint error, build error, type error, etc.)\n\n8. Return a structured summary:\n   - CI STATUS SECTION:\n     * Overall CI status (passing/failing)\n     * List of failed checks with:\n       - Check name\n       - Failure type\n       - Error message/location\n       - Suggested fix approach\n   - REVIEW COMMENTS SECTION:\n     * Total count of pending vs resolved comments\n     * List of actionable items with:\n       - Comment ID\n       - File and location\n       - What is being requested\n       - Suggested approach to address it\n   - Any clarifying questions that need user input\n\nBe thorough but concise. Focus on what the main agent needs to know to fix CI and address each comment."
    }
  },
  "command": {
    "commits_push": {
      "template": "commit and push (1 or more logical commits)\n\nAnalyze the current changes and create logical, well-structured commits with descriptive messages. Group related changes together and push all commits to the remote repository.",
      "description": "Create logical commits and push to remote",
      "agent": "build"
    },
    "single_commit_push": {
      "template": "commit and push all uncommited changes. If there's something that obviously doesn't need to be commited, stop and ask the user",
      "description": "Create a commit and push to remote",
      "agent": "build"
    },
    "rebase_master": {
      "template": "Create a backup branch. then: run git fetch and rebase on latest master. if there are any conflict, solve them logically according to the changes on the branch. If there were conflicts, give a summary of the conflicts and your decisions",
      "description": "Rebase on latest master",
      "agent": "build"
    },
    "prepare_pr": {
      "template": "Prepare current branch for PR with comprehensive review and fixes\n\nFollow these steps:\n1. Commit any uncommitted changes:\n   - Check git status to see uncommitted changes\n   - Create a logical commit with a descriptive message for any uncommitted work\n\n2. Review ALL changes on the branch since it diverged from main/master:\n   - Run `git diff main...HEAD` (or `git diff master...HEAD`) to see all changes\n   - Run `git log main..HEAD` (or `git log master..HEAD`) to see all commits\n   - Review the code thoroughly for:\n     a) Leftover or redundant code (commented-out code, unused variables, dead code paths)\n     b) Logic clarity - ensure code is explicit, simple, and modular\n     c) Fail-fast patterns - check errors are caught early and handled properly\n     d) Code smells (long functions, duplicated code, unclear naming, tight coupling)\n     e) Comments - go over all added comments and for each:\n        - Remove it if the code is self-explanatory\n        - Remove it but extract non-self-explanatory code into a function with descriptive name\n        - Keep it only if it explains the WHY (not the HOW)\n\n3. Fix any issues found:\n   - Remove redundant code\n   - Simplify complex logic\n   - Extract functions to improve modularity\n   - Add early returns and proper error handling\n   - Improve naming and structure\n   - Apply comment review decisions\n\n4. Run relevant tests:\n   - Identify which tests are relevant based on the changes\n   - Run those tests and ensure they pass\n   - Fix any test failures\n\nIMPORTANT: If you encounter any dilemma or ambiguity during the review (e.g., uncertain if code is redundant, unclear if a refactoring would break something, unsure about business logic), PAUSE and ask the user for guidance before proceeding.",
      "description": "Commit changes, review branch code, fix issues, run tests",
      "agent": "build"
    },
    "resolve_conflicts": {
      "template": "Resolve git conflicts on the current branch, then report on what you did. If you run into any ambiguity, pause and ask the user how to proceed",
      "description": "Resolve git conflicts",
      "agent": "build"
    },
    "pr_resolve": {
      "template": "Address PR review comments and CI failures on the current branch, commit changes, push, and mark comments as resolved.\n\nFollow this workflow:\n\n1. FIRST - Use the @pr-comments-analyzer subagent to gather and analyze all PR review comments AND CI failures:\n   - Invoke the pr-comments-analyzer agent using the Task tool\n   - Wait for it to return the structured analysis of comments and CI status\n\n2. Review the analysis and for any items that require clarification or have ambiguity, ask the user before proceeding.\n\n3. Address CI failures FIRST (they often block merging):\n   a) For each CI failure identified:\n      - Navigate to the relevant file/test\n      - Understand the error from the logs\n      - Fix the issue (test failure, lint error, type error, build error, etc.)\n   b) Run the relevant checks locally to verify fixes:\n      - For test failures: run the specific failing tests\n      - For lint errors: run the linter\n      - For type errors: run type checking\n      - For build errors: run the build\n\n4. Address review comments:\n   a) For each actionable comment:\n      - Navigate to the file and location mentioned\n      - Understand the context and what change is requested\n      - Make the appropriate code change\n      - If a comment is unclear or you disagree with it, ask the user how to proceed\n\n5. After addressing all issues:\n   a) Run the full test suite or relevant tests to ensure nothing is broken\n   b) Create a commit with a message summarizing:\n      - CI fixes made\n      - PR feedback addressed\n   c) Push the changes to the remote branch\n\n6. Mark resolved comments:\n   - For each comment that was addressed, use `gh api` to mark the review thread as resolved:\n     `gh api --method PUT repos/{owner}/{repo}/pulls/{pr_number}/comments/{comment_id}/replies -f body=\"Addressed\"`\n   - Or resolve the thread: `gh api graphql -f query='mutation { resolveReviewThread(input: {threadId: \"THREAD_ID\"}) { thread { isResolved } } }'`\n   - Note: You may need to find thread IDs using `gh api repos/{owner}/{repo}/pulls/{pr_number}/reviews`\n\n7. Provide a summary:\n   - CI failures fixed and how\n   - Review comments addressed and how\n   - Any items skipped and why\n   - Any follow-up items or remaining discussions\n\nIMPORTANT: If you encounter any ambiguity about how to address a CI failure or comment, STOP and ask the user for guidance.",
      "description": "Fix CI failures, address PR comments, commit, push, and resolve threads",
      "agent": "build"
    }
  }
}
