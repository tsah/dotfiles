#!/usr/bin/env python3

import json
import os
import shutil
import sqlite3
import subprocess
import argparse
import time
from collections import defaultdict
from datetime import datetime


DB_PATH = os.path.expanduser("~/.local/share/opencode/opencode.db")
HOME = os.path.expanduser("~")


RESET = "\033[0m"
COLORS = {
    "header": "\033[1;37m",
    "directory": "\033[36m",
    "title": "\033[90m",
    "age": "\033[90m",
    "generating": "\033[33m",
    "waiting question": "\033[36m",
    "waiting permission": "\033[35m",
    "done": "\033[32m",
    "starting": "\033[34m",
    "unknown": "\033[90m",
}


def read_text(path):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except OSError:
        return ""


def read_cmdline(pid):
    raw = read_text(f"/proc/{pid}/cmdline")
    if not raw:
        return []
    parts = [p for p in raw.split("\x00") if p]
    return parts


def has_color():
    return os.isatty(1) and os.environ.get("NO_COLOR") is None


def colorize(text, key):
    if not has_color():
        return text
    return f"{COLORS.get(key, '')}{text}{RESET}"


def shorten_path(path):
    if path == HOME:
        return "~"
    if path.startswith(HOME + "/"):
        return "~" + path[len(HOME) :]
    return path


def get_opencode_pids():
    pids = []

    try:
        result = subprocess.run(
            ["pgrep", "-x", "opencode"],
            check=False,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            for line in result.stdout.splitlines():
                line = line.strip()
                if line.isdigit():
                    pids.append(line)
    except OSError:
        pass

    if pids:
        return pids

    for entry in os.listdir("/proc"):
        if not entry.isdigit():
            continue
        if is_opencode_process(entry):
            pids.append(entry)

    return pids


def build_child_count_map():
    counts = defaultdict(int)
    for entry in os.listdir("/proc"):
        if not entry.isdigit():
            continue
        stat = read_text(f"/proc/{entry}/stat")
        if not stat:
            continue
        try:
            rest = stat.rsplit(") ", 1)[1].split()
            ppid = rest[1]
            if ppid.isdigit():
                counts[ppid] += 1
        except (IndexError, ValueError):
            continue
    return counts


def is_interactive_instance(cmdline):
    if not cmdline:
        return False

    if "--stdio" in cmdline:
        return False

    if len(cmdline) > 1:
        subcommands = {
            "completion",
            "acp",
            "mcp",
            "attach",
            "run",
            "debug",
            "auth",
            "agent",
            "upgrade",
            "uninstall",
            "serve",
            "web",
            "models",
            "stats",
            "export",
            "import",
            "github",
            "pr",
            "session",
            "db",
            "x",
        }
        second = cmdline[1]
        if second in subcommands:
            return False
        if second.endswith(".js"):
            return False

    return True


def is_opencode_process(pid):
    comm = read_text(f"/proc/{pid}/comm").strip()
    return comm == "opencode"


def infer_status(
    latest_message_data,
    latest_message_time,
    latest_tool_part_data,
    latest_tool_time,
    pid_child_count,
    is_run_mode,
):
    if latest_tool_part_data:
        try:
            tool_part = json.loads(latest_tool_part_data)
            if (
                tool_part.get("type") == "tool"
                and (tool_part.get("state") or {}).get("status") == "running"
                and latest_tool_time >= latest_message_time
            ):
                tool_name = tool_part.get("tool", "tool")
                if tool_name == "question":
                    return "waiting question", "question prompt"

                if pid_child_count == 0:
                    return "waiting permission", f"{tool_name}"
        except json.JSONDecodeError:
            pass

    if not latest_message_data:
        return "starting", ""

    try:
        payload = json.loads(latest_message_data)
    except json.JSONDecodeError:
        return "unknown", ""

    role = payload.get("role")
    time_obj = payload.get("time") or {}
    completed = time_obj.get("completed")

    if role == "user":
        return "generating", "awaiting assistant"

    if role == "assistant":
        if completed:
            if is_run_mode:
                return "done", "run mode"
            return "done", "awaiting next task"
        return "generating", "assistant thinking"

    return "unknown", ""


def status_rank(status):
    order = {
        "waiting permission": 0,
        "waiting question": 1,
        "generating": 2,
        "starting": 3,
        "done": 4,
        "unknown": 5,
    }
    return order.get(status, 99)


def format_age(epoch_ms):
    if not epoch_ms:
        return "-"
    seconds = max(0, int((datetime.now().timestamp() * 1000 - epoch_ms) / 1000))
    if seconds < 60:
        return f"{seconds}s"
    minutes = seconds // 60
    if minutes < 60:
        return f"{minutes}m"
    hours = minutes // 60
    return f"{hours}h"


def truncate_text(text, max_len=56):
    if text is None:
        return ""
    text = str(text).strip().replace("\n", " ")
    if max_len <= 0:
        return ""
    if len(text) <= max_len:
        return text
    if max_len <= 3:
        return text[:max_len]
    return text[: max_len - 3] + "..."


def compute_column_widths(rows):
    term_width = shutil.get_terminal_size((120, 20)).columns
    status_width = max(6, *(len(r["status"]) for r in rows))
    age_width = 3
    separators = 6

    remaining = term_width - status_width - age_width - separators
    if remaining < 12:
        remaining = 12

    min_dir = 10
    min_title = 0

    max_dir_len = max(9, *(len(r["directory"]) for r in rows))
    preferred_dir = min(max_dir_len, max(min_dir, int(remaining * 0.55)))
    dir_width = max(min_dir, min(preferred_dir, remaining - min_title))
    title_width = max(min_title, remaining - dir_width)

    return dir_width, status_width, title_width


def session_id_from_cmdline(cmdline):
    for i, arg in enumerate(cmdline):
        if arg in ("-s", "--session") and i + 1 < len(cmdline):
            return cmdline[i + 1]
    return ""


def tty_for_pid(pid):
    try:
        tty_path = os.readlink(f"/proc/{pid}/fd/0")
    except OSError:
        return ""

    if tty_path.startswith("/dev/"):
        return tty_path

    return ""


def process_start_ticks(pid):
    stat = read_text(f"/proc/{pid}/stat")
    if not stat:
        return 0
    try:
        rest = stat.rsplit(") ", 1)[1].split()
        return int(rest[19])
    except (IndexError, ValueError):
        return 0


def tmux_tty_lookup():
    lookup = {}
    if not shutil.which("tmux"):
        return lookup

    try:
        result = subprocess.run(
            [
                "tmux",
                "list-panes",
                "-a",
                "-F",
                "#{pane_tty}\t#{session_name}\t#{session_name}:#{window_index}.#{pane_index}",
            ],
            check=False,
            capture_output=True,
            text=True,
        )
    except OSError:
        return lookup

    if result.returncode != 0:
        return lookup

    for line in result.stdout.splitlines():
        parts = line.split("\t")
        if len(parts) != 3:
            continue
        pane_tty, session_name, pane_target = parts
        lookup[pane_tty] = {
            "session": session_name,
            "pane": pane_target,
        }

    return lookup


def main():
    parser = argparse.ArgumentParser(add_help=True)
    parser.add_argument("--tsv", action="store_true", help="output tab-separated rows")
    parser.add_argument("--no-cache", action="store_true", help="disable short-lived TSV cache")
    args = parser.parse_args()

    cache_path = f"/tmp/opencode-status-{os.getuid()}.tsv"
    cache_ttl_seconds = 2

    if args.tsv and not args.no_cache:
        try:
            st = os.stat(cache_path)
            if time.time() - st.st_mtime <= cache_ttl_seconds:
                cached = read_text(cache_path)
                if cached:
                    print(cached, end="")
                    return
        except OSError:
            pass

    pids = get_opencode_pids()

    if not pids:
        print("No running opencode instances.")
        return

    conn = None
    if os.path.isfile(DB_PATH):
        try:
            conn = sqlite3.connect(DB_PATH)
        except sqlite3.Error:
            conn = None

    instances = []
    tty_lookup = tmux_tty_lookup()
    child_counts = build_child_count_map()

    for pid in pids:
        cmdline = read_cmdline(pid)
        if not is_interactive_instance(cmdline):
            continue

        try:
            cwd = os.readlink(f"/proc/{pid}/cwd")
        except OSError:
            continue

        is_run_mode = len(cmdline) > 1 and cmdline[1] == "run"
        session_name = ""
        pane_target = ""
        session_id = session_id_from_cmdline(cmdline)

        tty = tty_for_pid(pid)
        if tty and tty in tty_lookup:
            session_name = tty_lookup[tty]["session"]
            pane_target = tty_lookup[tty]["pane"]

        instances.append(
            {
                "pid": pid,
                "cwd": cwd,
                "is_run_mode": is_run_mode,
                "session_name": session_name,
                "pane_target": pane_target,
                "session_id": session_id,
                "start_ticks": process_start_ticks(pid),
            }
        )

    if conn is not None:
        try:
            by_cwd = defaultdict(list)
            for inst in instances:
                by_cwd[inst["cwd"]].append(inst)

            for cwd, cwd_instances in by_cwd.items():
                explicit_ids = {
                    inst["session_id"]
                    for inst in cwd_instances
                    if inst["session_id"]
                }

                candidates = conn.execute(
                    """
                    SELECT id, title
                    FROM session
                    WHERE directory = ?
                      AND time_archived IS NULL
                    ORDER BY time_updated DESC
                    """,
                    (cwd,),
                ).fetchall()

                candidate_ids = [sid for sid, _ in candidates if sid not in explicit_ids]

                unresolved = [inst for inst in cwd_instances if not inst["session_id"]]
                unresolved.sort(key=lambda i: i["start_ticks"], reverse=True)

                for idx, inst in enumerate(unresolved):
                    if idx < len(candidate_ids):
                        inst["session_id"] = candidate_ids[idx]
                    elif candidates:
                        inst["session_id"] = candidates[0][0]
        except sqlite3.Error:
            pass

    if not instances:
        print("No running interactive opencode instances.")
        return

    grouped = defaultdict(list)

    session_meta_cache = {}
    last_message_cache = {}
    latest_tool_cache = {}

    for inst in instances:
        pid = inst["pid"]
        cwd = inst["cwd"]
        session_id = inst["session_id"]
        status = "starting"
        title = ""
        age = "-"

        if conn is not None and session_id:
            try:
                if session_id not in session_meta_cache:
                    session_meta_cache[session_id] = conn.execute(
                        "SELECT title FROM session WHERE id = ? LIMIT 1",
                        (session_id,),
                    ).fetchone()

                title_row = session_meta_cache.get(session_id)
                title = (title_row[0] if title_row else "") or ""

                if session_id not in last_message_cache:
                    last_message_cache[session_id] = conn.execute(
                        """
                        SELECT data, time_created
                        FROM message
                        WHERE session_id = ?
                        ORDER BY time_created DESC
                        LIMIT 1
                        """,
                        (session_id,),
                    ).fetchone()

                last_row = last_message_cache.get(session_id)
                last_data = last_row[0] if last_row else ""
                last_time = last_row[1] if last_row else 0

                if session_id not in latest_tool_cache:
                    latest_tool_cache[session_id] = conn.execute(
                        """
                        SELECT data, time_created
                        FROM part
                        WHERE session_id = ?
                          AND json_extract(data, '$.type') = 'tool'
                        ORDER BY time_created DESC
                        LIMIT 1
                        """,
                        (session_id,),
                    ).fetchone()

                latest_tool_row = latest_tool_cache.get(session_id)
                latest_tool_data = latest_tool_row[0] if latest_tool_row else ""
                latest_tool_time = latest_tool_row[1] if latest_tool_row else 0

                status, _detail = infer_status(
                    last_data,
                    last_time,
                    latest_tool_data,
                    latest_tool_time,
                    child_counts.get(str(pid), 0),
                    inst["is_run_mode"],
                )
                age = format_age(last_time)
            except sqlite3.Error:
                status = "unknown"

        grouped[cwd].append(
            (
                status,
                title,
                pid,
                age,
                inst["session_name"],
                inst["pane_target"],
            )
        )

    if conn is not None:
        conn.close()

    rows = []
    for cwd, entries in grouped.items():
        short_dir = shorten_path(cwd)
        sorted_entries = sorted(entries, key=lambda e: (status_rank(e[0]), int(e[2])))
        total = len(sorted_entries)

        for idx, entry in enumerate(sorted_entries, start=1):
            status, title, pid, age, session_name, pane_target = entry
            label = short_dir
            if total > 1:
                label = f"{short_dir} ({idx})"

            rows.append(
                {
                    "directory": label,
                    "status": status,
                    "title": title,
                    "age": age,
                    "session": session_name,
                    "pane": pane_target,
                    "pid": pid,
                }
            )

    rows.sort(key=lambda r: r["directory"])

    if args.tsv:
        lines = []
        for row in rows:
            directory = row["directory"].replace("\t", " ")
            status = row["status"].replace("\t", " ")
            title = (row["title"] or "").replace("\t", " ").replace("\n", " ")
            age = row["age"].replace("\t", " ")
            session = (row["session"] or "").replace("\t", " ")
            pane = (row["pane"] or "").replace("\t", " ")
            pid = str(row["pid"])
            lines.append("\t".join([directory, status, title, age, session, pane, pid]))

        output = "\n".join(lines)
        if output:
            output += "\n"
        print(output, end="")

        if not args.no_cache:
            try:
                with open(cache_path, "w", encoding="utf-8") as f:
                    f.write(output)
            except OSError:
                pass
        return

    dir_width, status_width, title_width = compute_column_widths(rows)

    for row in rows:
        row["directory"] = truncate_text(row["directory"], dir_width)
        row["title"] = truncate_text(row["title"], title_width)

    header = (
        f"{'DIRECTORY'.ljust(dir_width)}  "
        f"{'STATUS'.ljust(status_width)}  "
        f"{'TITLE'.ljust(title_width)}  "
        f"AGE"
    )
    print(colorize(header, "header"))

    for row in rows:
        print(
            f"{colorize(row['directory'].ljust(dir_width), 'directory')}  "
            f"{colorize(row['status'].ljust(status_width), row['status'])}  "
            f"{colorize(row['title'].ljust(title_width), 'title')}  "
            f"{colorize(row['age'].rjust(3), 'age')}"
        )


if __name__ == "__main__":
    main()
